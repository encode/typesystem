{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TypeSystem TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. Marshaling validators to/from JSON schema. Tokenizing JSON or YAML to provide positional error messages. 100% type annotated codebase. 100% test coverage. Zero hard dependencies. Requirements Python 3.6+ Installation $ pip3 install typesystem If you'd like you use the form rendering using jinja2 : $ pip3 install typesystem [ jinja2 ] If you'd like you use the YAML tokenization using pyyaml : $ pip3 install typesystem [ pyyaml ] Quickstart import typesystem artist_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( max_length = 100 ) } ) definitions = typesystem . Definitions () definitions [ \"Artist\" ] = artist_schema album_schema = typesystem . Schema ( fields = { \"title\" : typesystem . String ( max_length = 100 ), \"release_date\" : typesystem . Date (), \"artist\" : typesystem . Reference ( \"Artist\" , definitions = definitions ) } ) album = album_schema . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} Alternatives There are plenty of other great validation libraries for Python out there, including Marshmallow , Schematics , Voluptuous , Pydantic and many others. TypeSystem exists because I want a data validation library that offers first-class support for: Rendering validation classes into HTML forms. Marshaling to/from JSON Schema. Obtaining positional errors within JSON or YAML documents. \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Introduction"},{"location":"#typesystem","text":"TypeSystem is a comprehensive data validation library that gives you: Data validation. Object serialization & deserialization. Form rendering. Marshaling validators to/from JSON schema. Tokenizing JSON or YAML to provide positional error messages. 100% type annotated codebase. 100% test coverage. Zero hard dependencies.","title":"TypeSystem"},{"location":"#requirements","text":"Python 3.6+","title":"Requirements"},{"location":"#installation","text":"$ pip3 install typesystem If you'd like you use the form rendering using jinja2 : $ pip3 install typesystem [ jinja2 ] If you'd like you use the YAML tokenization using pyyaml : $ pip3 install typesystem [ pyyaml ]","title":"Installation"},{"location":"#quickstart","text":"import typesystem artist_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( max_length = 100 ) } ) definitions = typesystem . Definitions () definitions [ \"Artist\" ] = artist_schema album_schema = typesystem . Schema ( fields = { \"title\" : typesystem . String ( max_length = 100 ), \"release_date\" : typesystem . Date (), \"artist\" : typesystem . Reference ( \"Artist\" , definitions = definitions ) } ) album = album_schema . validate ({ \"title\" : \"Double Negative\" , \"release_date\" : \"2018-09-14\" , \"artist\" : { \"name\" : \"Low\" } }) print ( album ) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}}","title":"Quickstart"},{"location":"#alternatives","text":"There are plenty of other great validation libraries for Python out there, including Marshmallow , Schematics , Voluptuous , Pydantic and many others. TypeSystem exists because I want a data validation library that offers first-class support for: Rendering validation classes into HTML forms. Marshaling to/from JSON Schema. Obtaining positional errors within JSON or YAML documents. \u2014 \u2b50\ufe0f \u2014 TypeSystem is BSD licensed code. Designed & built in Brighton, England.","title":"Alternatives"},{"location":"examples/","text":"The following are examples of integrating typesystem against a Web framework. API validation & serialization Using typesystem for validation and serialization of a simple Web API. requirements.txt starlette typesystem uvicorn app.py import typesystem import uvicorn from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route users = [] user_schema = typesystem . Schema ( fields = { \"username\" : typesystem . String ( max_length = 100 ), \"is_admin\" : typesystem . Boolean ( default = False ), } ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( user ) app = Starlette ( debug = True , routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app ) Form rendering Using typesystem for a simple Web submission page. requirements.txt aiofiles # Static files support bootstrap4 # Form templates & static files jinja2 # Form rendering python-multipart # Form parsing starlette typesystem uvicorn app.py import typesystem import uvicorn from starlette.applications import Starlette from starlette.responses import RedirectResponse from starlette.routing import Mount , Route from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) bookings = [] booking_schema = typesystem . Schema ( fields = { \"start_date\" : typesystem . Date ( title = \"Start date\" ), \"end_date\" : typesystem . Date ( title = \"End date\" ), \"room\" : typesystem . Choice ( title = \"Room type\" , choices = [ ( \"double\" , \"Double room\" ), ( \"twin\" , \"Twin room\" ), ( \"single\" , \"Single room\" ), ], ), \"include_breakfast\" : typesystem . Boolean ( title = \"Include breakfast\" , default = False ), } ) async def homepage ( request ): form = forms . create_form ( booking_schema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) async def make_booking ( request ): data = await request . form () booking , errors = booking_schema . validate_or_error ( data ) if errors : form = forms . create_form ( booking_schema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) bookings . append ( booking ) return RedirectResponse ( request . url_for ( \"homepage\" ), status_code = 303 ) app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage , methods = [ \"GET\" ]), Route ( \"/\" , make_booking , methods = [ \"POST\" ]), Mount ( \"/statics\" , statics , name = \"static\" ), ], ) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, shrink-to-fit=no\" > < meta name = \"description\" content = \"\" > < meta name = \"author\" content = \"\" > < title > TypeSystem </ title > < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > < link href = \"{{ url_for('static', path='/css/base.css') }}\" rel = \"stylesheet\" > </ head > < body > < main role = \"main\" class = \"container\" > < div class = \"booking-list\" > < h4 > Current bookings </ h4 > < div > {% if bookings %} < ul > {% for booking in bookings %} < li > {{ booking }} </ li > {% endfor %} </ ul > {% else %} < em > None </ em > {% endif %} </ div > </ div > < hr /> < div class = \"booking-form\" > < h4 > New booking </ h4 > < form method = \"POST\" > {{ form }} < div class = \"submit-controls\" > < button type = \"submit\" class = \"btn btn-primary\" > Submit </ button > </ div > </ form > </ div > </ main > < script src = \"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity = \"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin = \"anonymous\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity = \"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin = \"anonymous\" ></ script > < script src = \"{{ url_for('static', path='js/bootstrap.min.js') }}\" ></ script > </ body > </ html > statics/css/base.css . container { padding-top : 20 px ; max-width : 500 px ; } . booking-list { padding : 20 px 0 30 px ; } . booking-list li { padding : 10 px 0 ; } . booking-form form { padding : 10 px 0 ; } . submit-controls { padding : 15 px 0 ; }","title":"Examples"},{"location":"examples/#api-validation-serialization","text":"Using typesystem for validation and serialization of a simple Web API. requirements.txt starlette typesystem uvicorn app.py import typesystem import uvicorn from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route users = [] user_schema = typesystem . Schema ( fields = { \"username\" : typesystem . String ( max_length = 100 ), \"is_admin\" : typesystem . Boolean ( default = False ), } ) async def list_users ( request ): return JSONResponse ({ \"users\" : [ dict ( user ) for user in users ]}) async def add_user ( request ): data = await request . json () user , errors = User . validate_or_error ( data ) if errors : return JSONResponse ( dict ( errors ), status_code = 400 ) users . append ( user ) return JSONResponse ( user ) app = Starlette ( debug = True , routes = [ Route ( '/' , list_users , methods = [ \"GET\" ]), Route ( '/' , add_user , methods = [ \"POST\" ]), ]) if __name__ == \"__main__\" : uvicorn . run ( app )","title":"API validation &amp; serialization"},{"location":"examples/#form-rendering","text":"Using typesystem for a simple Web submission page. requirements.txt aiofiles # Static files support bootstrap4 # Form templates & static files jinja2 # Form rendering python-multipart # Form parsing starlette typesystem uvicorn app.py import typesystem import uvicorn from starlette.applications import Starlette from starlette.responses import RedirectResponse from starlette.routing import Mount , Route from starlette.staticfiles import StaticFiles from starlette.templating import Jinja2Templates forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) templates = Jinja2Templates ( directory = \"templates\" ) statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) bookings = [] booking_schema = typesystem . Schema ( fields = { \"start_date\" : typesystem . Date ( title = \"Start date\" ), \"end_date\" : typesystem . Date ( title = \"End date\" ), \"room\" : typesystem . Choice ( title = \"Room type\" , choices = [ ( \"double\" , \"Double room\" ), ( \"twin\" , \"Twin room\" ), ( \"single\" , \"Single room\" ), ], ), \"include_breakfast\" : typesystem . Boolean ( title = \"Include breakfast\" , default = False ), } ) async def homepage ( request ): form = forms . create_form ( booking_schema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) async def make_booking ( request ): data = await request . form () booking , errors = booking_schema . validate_or_error ( data ) if errors : form = forms . create_form ( booking_schema ) context = { \"request\" : request , \"form\" : form , \"bookings\" : bookings } return templates . TemplateResponse ( \"index.html\" , context ) bookings . append ( booking ) return RedirectResponse ( request . url_for ( \"homepage\" ), status_code = 303 ) app = Starlette ( debug = True , routes = [ Route ( \"/\" , homepage , methods = [ \"GET\" ]), Route ( \"/\" , make_booking , methods = [ \"POST\" ]), Mount ( \"/statics\" , statics , name = \"static\" ), ], ) if __name__ == \"__main__\" : uvicorn . run ( app ) templates/index.html <!doctype html> < html lang = \"en\" > < head > < meta charset = \"utf-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1, shrink-to-fit=no\" > < meta name = \"description\" content = \"\" > < meta name = \"author\" content = \"\" > < title > TypeSystem </ title > < link href = \"{{ url_for('static', path='/css/bootstrap.min.css') }}\" rel = \"stylesheet\" > < link href = \"{{ url_for('static', path='/css/base.css') }}\" rel = \"stylesheet\" > </ head > < body > < main role = \"main\" class = \"container\" > < div class = \"booking-list\" > < h4 > Current bookings </ h4 > < div > {% if bookings %} < ul > {% for booking in bookings %} < li > {{ booking }} </ li > {% endfor %} </ ul > {% else %} < em > None </ em > {% endif %} </ div > </ div > < hr /> < div class = \"booking-form\" > < h4 > New booking </ h4 > < form method = \"POST\" > {{ form }} < div class = \"submit-controls\" > < button type = \"submit\" class = \"btn btn-primary\" > Submit </ button > </ div > </ form > </ div > </ main > < script src = \"https://code.jquery.com/jquery-3.2.1.slim.min.js\" integrity = \"sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN\" crossorigin = \"anonymous\" ></ script > < script src = \"https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.12.9/umd/popper.min.js\" integrity = \"sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q\" crossorigin = \"anonymous\" ></ script > < script src = \"{{ url_for('static', path='js/bootstrap.min.js') }}\" ></ script > </ body > </ html > statics/css/base.css . container { padding-top : 20 px ; max-width : 500 px ; } . booking-list { padding : 20 px 0 30 px ; } . booking-list li { padding : 10 px 0 ; } . booking-form form { padding : 10 px 0 ; } . submit-controls { padding : 15 px 0 ; }","title":"Form rendering"},{"location":"fields/","text":"Fields are passed as a dictionary to the Schema classes: import typesystem user_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ()}) definitions = typesystem . Definitions () definitions [ \"User\" ] = user_schema organization_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( title = \"Name\" , max_length = 100 ), \"date_created\" : typesystem . Date ( title = \"Date created\" , default = datetime . date . today ), \"owner\" : typesystem . Reference ( to = \"User\" , allow_null = True , definitions = definitions ), } ) Fields are always required in inputs, unless a default value is set. Setting allow_null to True will set the default to None . (Unless default is already set.) Setting allow_blank to True will set the default to \"\" . (Unless default or allow_null is already set.) All fields support the following arguments. Arguments : title - A string to use when labelling the input. Default: None description - A string describing the input. Default: None default - A value to be used if no input is provided for this field. May be a callable, such as datetime.datetime.now . Default: NO_DEFAULT allow_null - A boolean determining if None values are valid. Default: False read_only - A boolean determining if field should be considered as read-only, this is usually used in form rendering. Default: False Using fields directly You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ... Textual data types String Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False trim_whitespace - A boolean indicating if leading/trailing whitespace should be removed on validation. Default: True max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A regular expression that must match. This can be either a string or a compiled regular expression. E.g. pattern=\"^[A-Za-z]+$\" Default: None format - A string used to indicate a semantic type, such as \"email\" , \"url\" , or \"color\" . Default: None coerce_types - A boolean determining if type casting should be done, E.g. changing None to \"\" if allow_blank . Default: True Text Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> . Password Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"password\"> . Email Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"email\"> . IPAddress Validates IPv4 and IPv6 addresses. Returns ipaddress.IPv4Address or ipaddress.IPv6Address based on input. URL Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"url\"> . Boolean data types Boolean Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem . Boolean ( default = False ) Because all fields are required unless a default is given, you'll typically want to use default=False . This is particularly true if you want to render boolean fields as HTML checkboxes, since they do not submit any input if unchecked. Numeric data types Number The base class for Integer , Float , and Decimal . You won't typically want to use this class directly, since the subclasses provide more precise behaviour. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. E.g. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. E.g. multiple_of=2 will only validate even integers. Default: None Integer Takes the same arguments as Number . Returns instances of int . Float Takes the same arguments as Number . Returns instances of float . Decimal Takes the same arguments as Number . Returns instances of decimal.Decimal . Enumeration data types Choice Provides a fixed set of options to select from. Represented in HTML forms as a <select> . Arguments : choices - A list of two-tuples of (choice, description) . Default: None Date and time data types DateTime Validates ISO 8601 formatted datetimes. For example \"2020-02-29T12:34:56Z\" . Returns datetime.datetime instances. Date Validates ISO 8601 formatted dates. For example \"2020-02-29\" . Returns datetime.date instances. Time Validates ISO 8601 formatted times. For example \"12:34:56\" . Returns datetime.time instances. Composite data types Array Used to validate a list of data. For example: # Validates data like `[8, 7, 0, 8, 4, 5]` ratings = typesystem . Array ( items = typesystem . Integer ( minimum = 0 , maximum = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False Object Used to validate a dictionary of data. # Validates data like `{\"address\": \"12 Steeple close\", \"delivery note\": \"Leave by porch\"}` extra_metadata = typesystem . Object ( properties = typesystem . String ( max_length = 100 )) Schema classes implement their validation behaviour by generating an Object field, and automatically determining the properties and required attributes. You'll typically want to use typesystem.Reference(to=\"SomeSchema\") rather than using the Object field directly, but it can be useful if you have a more complex data structure that you need to validate. Arguments : properties - Either a Field , used to validate each value in the object. Or a dictionary of Field instances, used to validate each item in the list, by field name. Default: None pattern_properties - A dictionary mapping regex-style strings to field instances. Used to validate any items not in properties that have a key matching the regex. Default: None additional_properties - Either a boolean, used to indicate if additional properties are allowed, or a Field used to validate any items not in properties or pattern_properties . If None then additional properties are allowed, but are not included in the validated value. Default: None min_properties - An integer representing the minimum number of properties that must be included. max_properties - An integer representing the maximum number of properties that may be included. required - A list of strings indicating any fields that are strictly required in the input. Reference Used to reference a nested schema. For example: owner = typesystem . Reference ( to = \"User\" , allow_null = True , definitions = definitions ) Arguments : to - Name of schema defined in definitions. Required definitions - Definitions instance. Required Other data types UUID Validates UUID in the format of 32 hexadecimal characters, separated by hyphens. For example \"cd11b0d7-d8b3-4b5c-8159-70f5c9ea96ab\" . Returns uuid.UUID instances.","title":"Fields"},{"location":"fields/#using-fields-directly","text":"You can use fields to validate data directly, rather than using them on a schema class. This is useful if you have a general datastructure that requires validation. For instance, we could validate a dictionary of integers, like so: validator = typesystem . Object ( properties = typesystem . Integer ()) value = validator . validate ( data ) # May raise `ValidationError` Or returning a two-tuple of (value, ValidationError) : validator = typesystem . Object ( properties = typesystem . Integer ()) value , error = validator . validate_or_error ( data ) if error : ... else : ...","title":"Using fields directly"},{"location":"fields/#textual-data-types","text":"","title":"Textual data types"},{"location":"fields/#string","text":"Validates single-line text inputs. For example: username = typesystem.String(max_length=100) Arguments : allow_blank - A boolean indicating if the empty string should validate. Default: False trim_whitespace - A boolean indicating if leading/trailing whitespace should be removed on validation. Default: True max_length - A maximum number of characters that valid input stings may contain. Default: None min_length - A minimum number of characters that valid input stings may contain. Default: None pattern - A regular expression that must match. This can be either a string or a compiled regular expression. E.g. pattern=\"^[A-Za-z]+$\" Default: None format - A string used to indicate a semantic type, such as \"email\" , \"url\" , or \"color\" . Default: None coerce_types - A boolean determining if type casting should be done, E.g. changing None to \"\" if allow_blank . Default: True","title":"String"},{"location":"fields/#text","text":"Validates multi-line strings. Takes the same arguments as String . Represented in HTML forms as a <textarea> .","title":"Text"},{"location":"fields/#password","text":"Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"password\"> .","title":"Password"},{"location":"fields/#email","text":"Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"email\"> .","title":"Email"},{"location":"fields/#ipaddress","text":"Validates IPv4 and IPv6 addresses. Returns ipaddress.IPv4Address or ipaddress.IPv6Address based on input.","title":"IPAddress"},{"location":"fields/#url","text":"Similar to String and takes the same arguments. Represented in HTML forms as a <input type=\"url\"> .","title":"URL"},{"location":"fields/#boolean-data-types","text":"","title":"Boolean data types"},{"location":"fields/#boolean","text":"Represented in HTML forms as a <checkbox> . For example: is_admin = typesystem . Boolean ( default = False ) Because all fields are required unless a default is given, you'll typically want to use default=False . This is particularly true if you want to render boolean fields as HTML checkboxes, since they do not submit any input if unchecked.","title":"Boolean"},{"location":"fields/#numeric-data-types","text":"","title":"Numeric data types"},{"location":"fields/#number","text":"The base class for Integer , Float , and Decimal . You won't typically want to use this class directly, since the subclasses provide more precise behaviour. Arguments : minimum - A number representing the minimum allowed value. Inputs must be greater than or equal to this to validate. Default: None maximum - A number representing the maximum allowed value. Inputs must be less than or equal to this to validate. Default: None exclusive_minimum - A number representing an exclusive minimum. Inputs must be greater than this to validate. Default: None exclusive_maximum - A number representing an exclusive maximum. Inputs must be less than this to validate. Default: None precision - A string representing the decimal precision to truncate input with. E.g. precision=\"0.001\" . Default: None multiple_of - A number giving a value that inputs must be a strict multiple of in order to validate. E.g. multiple_of=2 will only validate even integers. Default: None","title":"Number"},{"location":"fields/#integer","text":"Takes the same arguments as Number . Returns instances of int .","title":"Integer"},{"location":"fields/#float","text":"Takes the same arguments as Number . Returns instances of float .","title":"Float"},{"location":"fields/#decimal","text":"Takes the same arguments as Number . Returns instances of decimal.Decimal .","title":"Decimal"},{"location":"fields/#enumeration-data-types","text":"","title":"Enumeration data types"},{"location":"fields/#choice","text":"Provides a fixed set of options to select from. Represented in HTML forms as a <select> . Arguments : choices - A list of two-tuples of (choice, description) . Default: None","title":"Choice"},{"location":"fields/#date-and-time-data-types","text":"","title":"Date and time data types"},{"location":"fields/#datetime","text":"Validates ISO 8601 formatted datetimes. For example \"2020-02-29T12:34:56Z\" . Returns datetime.datetime instances.","title":"DateTime"},{"location":"fields/#date","text":"Validates ISO 8601 formatted dates. For example \"2020-02-29\" . Returns datetime.date instances.","title":"Date"},{"location":"fields/#time","text":"Validates ISO 8601 formatted times. For example \"12:34:56\" . Returns datetime.time instances.","title":"Time"},{"location":"fields/#composite-data-types","text":"","title":"Composite data types"},{"location":"fields/#array","text":"Used to validate a list of data. For example: # Validates data like `[8, 7, 0, 8, 4, 5]` ratings = typesystem . Array ( items = typesystem . Integer ( minimum = 0 , maximum = 10 )) Arguments : items - Either a Field , used to validate each item in the list. Or a list of Field instances, used to validate each item in the list, positionally. Default: None additional_items - Only valid if items is a list. Either True or False , or a Field . Used to validate each additional item in the list. Default: False min_items - An integer, indicating the minimum number of items that must be present in the list. Default: None max_items - An integer, indicating the maximum number of items that may be present in the list. Default: None exact_items - An integer, indicating the exact number of items that must be present in the list. Default: None unique_items - A boolean. Used to determine if duplicate items are allowed in the list. Default: False","title":"Array"},{"location":"fields/#object","text":"Used to validate a dictionary of data. # Validates data like `{\"address\": \"12 Steeple close\", \"delivery note\": \"Leave by porch\"}` extra_metadata = typesystem . Object ( properties = typesystem . String ( max_length = 100 )) Schema classes implement their validation behaviour by generating an Object field, and automatically determining the properties and required attributes. You'll typically want to use typesystem.Reference(to=\"SomeSchema\") rather than using the Object field directly, but it can be useful if you have a more complex data structure that you need to validate. Arguments : properties - Either a Field , used to validate each value in the object. Or a dictionary of Field instances, used to validate each item in the list, by field name. Default: None pattern_properties - A dictionary mapping regex-style strings to field instances. Used to validate any items not in properties that have a key matching the regex. Default: None additional_properties - Either a boolean, used to indicate if additional properties are allowed, or a Field used to validate any items not in properties or pattern_properties . If None then additional properties are allowed, but are not included in the validated value. Default: None min_properties - An integer representing the minimum number of properties that must be included. max_properties - An integer representing the maximum number of properties that may be included. required - A list of strings indicating any fields that are strictly required in the input.","title":"Object"},{"location":"fields/#reference","text":"Used to reference a nested schema. For example: owner = typesystem . Reference ( to = \"User\" , allow_null = True , definitions = definitions ) Arguments : to - Name of schema defined in definitions. Required definitions - Definitions instance. Required","title":"Reference"},{"location":"fields/#other-data-types","text":"","title":"Other data types"},{"location":"fields/#uuid","text":"Validates UUID in the format of 32 hexadecimal characters, separated by hyphens. For example \"cd11b0d7-d8b3-4b5c-8159-70f5c9ea96ab\" . Returns uuid.UUID instances.","title":"UUID"},{"location":"forms/","text":"TypeSystem gives you form rendering support, which you can either style and customize yourself, or use together with a pre-packaged theme. Let's take a look: import typesystem forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) # Use the default templates. booking_schema = typesystem . Schema ( fields = { \"start_date\" : typesystem . Date ( title = \"Start date\" ), \"end_date\" : typesystem . Date ( title = \"End date\" ), \"room\" : typesystem . Choice ( title = \"Room type\" , choices = [ ( 'double' , 'Double room' ), ( 'twin' , 'Twin room' ), ( 'single' , 'Single room' ) ]), \"include_breakfast\" : typesystem . Boolean ( title = \"Include breakfast\" , default = False ), } ) form = forms . create_form ( booking_schema ) print ( form ) That'll render an HTML form which looks something like this: The default templates included by typesystem use tables to provide a simple functional layout. Notice that only the fields in the form are rendered. The surrounding <form> , <table> , and <input type=\"submit\"> tags should be included directly in any template that renders the form. < tr > < td > < label for = \"start-date\" > Start date </ label > </ td > < td > < input type = \"date\" id = \"start-date\" name = \"start_date\" required > </ td > </ tr > < tr > < td > < label for = \"end-date\" > End date </ label > </ td > < td > < input type = \"date\" id = \"end-date\" name = \"end_date\" required > </ td > </ tr > < tr > < td > < label for = \"room\" > Room type </ label > </ td > < td > < select id = \"room\" name = \"room\" > < option ></ option > < option value = \"double\" > Double room </ option > < option value = \"twin\" > Twin room </ option > < option value = \"single\" > Single room </ option > </ select > </ td > </ tr > < tr > < td > < label for = \"include-breakfast\" > Include breakfast </ label > </ td > < td > < input type = \"checkbox\" id = \"include-breakfast\" name = \"include_breakfast\" value = \"true\" > </ td > </ tr > You can include a form inside a Jinja2 template by passing it as context, and rendering the context value. Make sure to include the surrounding tags: < form action = \"/\" method = \"POST\" > < table > {{ form }} < tr > < td ></ td > < td >< input type = \"submit\" value = \"Make booking\" /></ td > </ tr > </ table > </ form > Including values and errors We can include values in a form like so: initial_values = { 'room' : 'double' , 'include_breakfast' : True } form = forms . create_form ( booking_schema , values = initial_values ) Customizing field rendering If you'd like to override the default field rendering you can switch to using your own custom templates. Switch this line: forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) To instead use a templates directories: forms = typesystem . Jinja2Forms ( directory = \"templates\" ) You'll need to provide the following templates: forms/checkbox.html forms/input.html forms/select.html forms/textarea.html Using a packaged theme You can also use a pre-packaged theme, such as Bootstrap 4: # This pypi package includes `typesystem` form templates, # and pre-packaged static files. $ pip install bootstrap4 forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) The bootstrap4 package also provides the static CSS and JavaScript files, which you can easily serve up from Starlette's StaticFiles application: # Serve everything in the local \"statics\" directory plus everything # in the \"statics\" directory of the `bootstrap4` package. statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) That will then render HTML forms using Bootstrap:","title":"Forms"},{"location":"forms/#including-values-and-errors","text":"We can include values in a form like so: initial_values = { 'room' : 'double' , 'include_breakfast' : True } form = forms . create_form ( booking_schema , values = initial_values )","title":"Including values and errors"},{"location":"forms/#customizing-field-rendering","text":"If you'd like to override the default field rendering you can switch to using your own custom templates. Switch this line: forms = typesystem . Jinja2Forms ( package = \"typesystem\" ) To instead use a templates directories: forms = typesystem . Jinja2Forms ( directory = \"templates\" ) You'll need to provide the following templates: forms/checkbox.html forms/input.html forms/select.html forms/textarea.html","title":"Customizing field rendering"},{"location":"forms/#using-a-packaged-theme","text":"You can also use a pre-packaged theme, such as Bootstrap 4: # This pypi package includes `typesystem` form templates, # and pre-packaged static files. $ pip install bootstrap4 forms = typesystem . Jinja2Forms ( package = \"bootstrap4\" ) The bootstrap4 package also provides the static CSS and JavaScript files, which you can easily serve up from Starlette's StaticFiles application: # Serve everything in the local \"statics\" directory plus everything # in the \"statics\" directory of the `bootstrap4` package. statics = StaticFiles ( directory = \"statics\" , packages = [ \"bootstrap4\" ]) That will then render HTML forms using Bootstrap:","title":"Using a packaged theme"},{"location":"json_schema/","text":"TypeSystem can convert Schema or Field instances to/from JSON Schema. Note TypeSystem only supports $ref pointers that use the standard \"components/schemas\" namespace to store referenced schemas. All references should be of the style {\"$ref\": \"#/components/schemas/...\"} . Using hyperlinked references, relative references, or references to parts of the document other than \"components/schemas\" is not supported. Let's define a schema, and dump it out into a JSON schema document: import json import typesystem booking_schema = typesystem . Schema ( fields = { \"start_date\" : typesystem . Date ( title = \"Start date\" ), \"end_date\" : typesystem . Date ( title = \"End date\" ), \"room\" : typesystem . Choice ( title = \"Room type\" , choices = [ ( 'double' , 'Double room' ), ( 'twin' , 'Twin room' ), ( 'single' , 'Single room' ) ]), \"include_breakfast\" : typesystem . Boolean ( title = \"Include breakfast\" , default = False ), } ) schema = typesystem . to_json_schema ( booking_schema ) print ( json . dumps ( schema , indent = 4 )) That will print the following JSON schema document: { \"type\" : \"object\" , \"properties\" : { \"start_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"end_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"room\" : { \"enum\" : [ \"double\" , \"twin\" , \"single\" ] }, \"include_breakfast\" : { \"type\" : \"boolean\" , \"default\" : false } }, \"required\" : [ \"start_date\" , \"end_date\" , \"room\" ] } We can also convert in the other direction: import typesystem schema = { \"type\" : \"object\" , \"properties\" : { \"start_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"end_date\" : { \"type\" : \"string\" , \"minLength\" : 1 , \"format\" : \"date\" }, \"room\" : { \"enum\" : [ \"double\" , \"twin\" , \"single\" ] }, \"include_breakfast\" : { \"type\" : \"boolean\" , \"default\" : False } }, \"required\" : [ \"start_date\" , \"end_date\" , \"room\" ] } validator = typesystem . from_json_schema ( schema ) validator . validate ({ 'start_date' : '2021-01-01' , 'end_date' : '2021-01-03' }) # raises `ValidationError: {'room': 'This field is required.'}`","title":"JSON Schema"},{"location":"references/","text":"References are a special type of field used to interlink schemas. The simplest way to use a reference, is with a schema class as a the target. import typesystem artist_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( max_length = 100 ) } ) definitions = typesystem . Definitions () definitions [ \"Artist\" ] = artist_schema album_schema = typesystem . Schema ( fields = { \"title\" : typesystem . String ( max_length = 100 ), \"release_date\" : typesystem . Date (), \"artist\" : typesystem . Reference ( to = \"Artist\" , definitions = definitions ), } ) Registering schema instances against a Definitions instance is particularly useful if you're using JSON schema to document the input and output types of a Web API, since you can easily dump all the type definitions: import json import typesystem definitions = typesystem . Definitions () artist_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( max_length = 100 ) } ) album_schema = typesystem . Schema ( fields = { \"title\" : typesystem . String ( max_length = 100 ), \"release_date\" : typesystem . Date (), \"artist\" : typesystem . Reference ( to = \"Artist\" , definitions = definitions ), } ) definitions [ \"Artist\" ] = artist_schema definitions [ \"Album\" ] = album_schema document = typesystem . to_json_schema ( definitions ) print ( json . dumps ( document , indent = 4 )) # { # \"components\":{ # \"schemas\":{ # \"Artist\":{ # \"type\":\"object\", # \"properties\":{ # \"name\":{ # \"type\":\"string\", # \"minLength\":1, # \"maxLength\":100 # } # }, # \"required\":[ # \"name\" # ] # }, # \"Album\":{ # \"type\":\"object\", # \"properties\":{ # \"title\":{ # \"type\":\"string\", # \"minLength\":1, # \"maxLength\":100 # }, # \"release_date\":{ # \"type\":\"string\", # \"minLength\":1, # \"format\":\"date\" # }, # \"artist\":{ # \"$ref\":\"#/components/schemas/Artist\" # } # }, # \"required\":[ # \"title\", # \"release_date\", # \"artist\" # ] # } # } # } # }","title":"References"},{"location":"schemas/","text":"Let's start by defining some schemas. import typesystem artist_schema = typesystem . Schema ( fields = { \"name\" : typesystem . String ( max_length = 100 ) } ) definitions = typesystem . Definitions () definitions [ \"Artist\" ] = artist_schema album_schema = typesystem . Schema ( fields = { \"title\" : typesystem . String ( max_length = 100 ), \"release_date\" : typesystem . Date (), \"artist\" : typesystem . Reference ( \"Artist\" , definitions = definitions ) } ) We've got some incoming user data that we'd like to validate against our schema. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } We can validate the data against a Schema by using .validate(data) . album = album_schema . validate ( data ) If validation succeeds, this will return an dict . If validation fails, a ValidationError will be raised. Alternatively we can use .validate_or_error(data) , which will return a two-tuple of (value, error) . Either one of value or error will be None . album , error = album_schema . validate_or_error ( data ) if error : ... else : ... Working with validation errors The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = album_schema . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = album_schema . validate_or_error ( invalid_data ) for message in error . messages (): print ( f ' { message . index !r} , { message . code !r} , { message . text !r} )' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.' Working with schema instances Python dictionaries are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = album_schema . validate ( data ) print ( album ) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} You can also serialize data using the schema instance: artist = artist_schema . serialize ({ 'name' : 'Low' }) album = album_schema . serialize ({ 'title' : 'Double Negative' , 'artist' : artist }) If serialize directly, validation is not done and data returned may be sparsely populated. Any unused attributes without a default will not be returned. artist = artist_schema . serialize ({ 'name' : 'Low' }) album = album_schema . serialize ({ 'title' : 'Double Negative' , 'artist' : artist }) print ( album ) # {'title': 'Double Negative', 'artist': {'name': 'Low'}} [sparse] album [ 'release_date' ] # KetError: 'release_date' Sparsely serialized data can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known. Using strict validation By default, additional properties in the incoming user data is ignored. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' }, 'num_tracks' : 11 } After validating against the schema, the num_tracks property is not present in the returned data. album = album_schema . validate ( data ) album [ 'num_tracks] # KeyError: 'num_tracks'","title":"Schemas"},{"location":"schemas/#working-with-validation-errors","text":"The ValidationError class presents a dict-like interface: invalid_data = { 'title' : 'Double Negative' , 'release_date' : '2018.09.14' , 'artist' : { 'name' : 'x' * 1000 } } album , error = album_schema . validate_or_error ( invalid_data ) print ( dict ( error )) # {'release_date': 'Must be a valid date format.', 'artist': {'name': 'Must have no more than 100 characters.'}} print ( list ( error . keys ())) # ['release_date', 'artist'] If you want more precise information about exactly what error messages exist, you can access each individual message with error.messages() : album , error = album_schema . validate_or_error ( invalid_data ) for message in error . messages (): print ( f ' { message . index !r} , { message . code !r} , { message . text !r} )' ) # ['release_date'], 'format', 'Must be a valid date format.' # ['artist', 'name'], 'max_length', 'Must have no more than 100 characters.'","title":"Working with validation errors"},{"location":"schemas/#working-with-schema-instances","text":"Python dictionaries are returned by calls to .validate() . data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' } } album = album_schema . validate ( data ) print ( album ) # {'title': 'Double Negative', 'release_date': '2018-09-14', 'artist': {'name': 'Low'}} You can also serialize data using the schema instance: artist = artist_schema . serialize ({ 'name' : 'Low' }) album = album_schema . serialize ({ 'title' : 'Double Negative' , 'artist' : artist }) If serialize directly, validation is not done and data returned may be sparsely populated. Any unused attributes without a default will not be returned. artist = artist_schema . serialize ({ 'name' : 'Low' }) album = album_schema . serialize ({ 'title' : 'Double Negative' , 'artist' : artist }) print ( album ) # {'title': 'Double Negative', 'artist': {'name': 'Low'}} [sparse] album [ 'release_date' ] # KetError: 'release_date' Sparsely serialized data can be useful for cases of loading data from database, when you do not need to retrieve all the fields, or for cases of loading nested data where no database join has been made, and only the primary key of the relationship is known.","title":"Working with schema instances"},{"location":"schemas/#using-strict-validation","text":"By default, additional properties in the incoming user data is ignored. data = { 'title' : 'Double Negative' , 'release_date' : '2018-09-14' , 'artist' : { 'name' : 'Low' }, 'num_tracks' : 11 } After validating against the schema, the num_tracks property is not present in the returned data. album = album_schema . validate ( data ) album [ 'num_tracks] # KeyError: 'num_tracks'","title":"Using strict validation"},{"location":"tokenized_errors/","text":"For JSON and YAML content, TypeSystem can provide error messages with position indicators showing exactly where the error occurred in the raw textual content. import typesystem config_schema = typesystem . Schema ( fields = { \"num_worker_processes\" : typesystem . Integer (), \"enable_auto_reload\" : typesystem . Boolean (), } ) text = '''{ \"num_worker_processes\": \"x\", \"enable_auto_reload\": \"true\" }''' try : typesystem . validate_json ( text , validator = config_schema ) except ( typesystem . ValidationError , typesystem . ParseError ) as exc : for message in exc . messages (): line_no = message . start_position . line_no column_no = message . start_position . column_no print ( f \"Error { message . text !r} at line { line_no } , column { column_no } .\" ) # Error 'Must be a number.' at line 2, column 29. The two functions for parsing content and providing positional error messages are: validate_json(text_or_bytes, validator) validate_yaml(text_or_bytes, validator) In both cases validator may either be a Schema or a Field instance.","title":"Tokenized Errors"}]}